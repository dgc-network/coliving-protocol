// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * API
 * Coliving V1 API
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    DigitalContentResponse,
    DigitalContentResponseFromJSON,
    DigitalContentResponseToJSON,
    DigitalContentSearch,
    DigitalContentSearchFromJSON,
    DigitalContentSearchToJSON,
    DigitalContentsResponse,
    DigitalContentsResponseFromJSON,
    DigitalContentsResponseToJSON,
} from '../models';

export interface GetBulkDigitalContentsRequest {
    /**
     * The permalink of the digital_content(s)
     */
    permalink?: Array<string>;
    /**
     * The ID of the digital_content(s)
     */
    id?: Array<string>;
}

export interface GetDigitalContentRequest {
    /**
     * A DigitalContent ID
     */
    digitalContentId: string;
}

export interface GetTrendingDigitalContentsRequest {
    /**
     * Filter trending to a specified genre
     */
    genre?: string;
    /**
     * Calculate trending over a specified time range
     */
    time?: GetTrendingDigitalContentsTimeEnum;
}

export interface SearchDigitalContentsRequest {
    /**
     * The search query
     */
    query: string;
    /**
     * Return only downloadable digitalContents
     */
    onlyDownloadable?: string;
}

export interface StreamDigitalContentRequest {
    /**
     * A DigitalContent ID
     */
    digitalContentId: string;
}

/**
 * 
 */
export class DigitalContentsApi extends runtime.BaseAPI {

    /**
     * Gets a list of digitalContents using their IDs or permalinks
     */
    async getBulkDigitalContents(requestParameters: GetBulkDigitalContentsRequest = {}): Promise<NonNullable<DigitalContentsResponse["data"]>> {
        const queryParameters: any = {};

        if (requestParameters.permalink) {
            queryParameters['permalink'] = requestParameters.permalink;
        }

        if (requestParameters.id) {
            queryParameters['id'] = requestParameters.id;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/digitalContents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<DigitalContentsResponse["data"]>>;
    }

    /**
     * Gets a digital_content by ID
     */
    async getDigitalContent(requestParameters: GetDigitalContentRequest): Promise<NonNullable<DigitalContentResponse["data"]>> {
        if (requestParameters.digitalContentId === null || requestParameters.digitalContentId === undefined) {
            throw new runtime.RequiredError('digitalContentId','Required parameter requestParameters.digitalContentId was null or undefined when calling getDigitalContent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/digital_contents/{digital_content_id}`.replace(`{${"digital_content_id"}}`, encodeURIComponent(String(requestParameters.digitalContentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<DigitalContentResponse["data"]>>;
    }

    /**
     * Gets the top 100 trending (most popular) digitalContents on Coliving
     */
    async getTrendingDigitalContents(requestParameters: GetTrendingDigitalContentsRequest = {}): Promise<NonNullable<DigitalContentsResponse["data"]>> {
        const queryParameters: any = {};

        if (requestParameters.genre !== undefined) {
            queryParameters['genre'] = requestParameters.genre;
        }

        if (requestParameters.time !== undefined) {
            queryParameters['time'] = requestParameters.time;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/digital_contents/trending`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<DigitalContentsResponse["data"]>>;
    }

    /**
     * Search for a digital_content or digitalContents
     */
    async searchDigitalContents(requestParameters: SearchDigitalContentsRequest): Promise<NonNullable<DigitalContentSearch["data"]>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling searchDigitalContents.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.onlyDownloadable !== undefined) {
            queryParameters['only_downloadable'] = requestParameters.onlyDownloadable;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        return this.request({
            path: `/digital_contents/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }) as Promise<NonNullable<DigitalContentSearch["data"]>>;
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetTrendingDigitalContentsTimeEnum {
    Week = 'week',
    Month = 'month',
    Year = 'year',
    AllTime = 'allTime'
}

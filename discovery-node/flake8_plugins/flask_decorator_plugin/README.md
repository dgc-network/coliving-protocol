# Flask Decorator Plugin

A Flake8 plugin to more strictly control Flask RestX API decorators.

## Issue Types

| Code   | Meaning                                                             |
| ------ | ------------------------------------------------------------------- |
| FDP001 | Don't use query params in `@api.doc()`. Use `@api.expect()` instead |
| FDP002 | Decorators are out of order                                         |
| FDP003 | Keyword args of `@api.doc()` are out of order                       |
| FDP004 | Route parameter is missing a description                            |
| FDP005 | Route method doesn't have an ID documented                          |

## IMPORTANT NOTES

- No rules run on routes marked `doc=False`.
- Route parameters can't be parsed if not using literal constants for the route (false negatives)
- Assumes using classes for resources, not route functions, and that routes are defined at the class level

## Rationale

### FDP001: Non-route parameter "{parameter}" specified in @api.doc(). Use @api.expects() with a RequestParser instead for query parameters.

Using `@api.doc()` for non-route parameters can cause the request parser arguments to become out of sync with the documentation. Using a request parser in combination with `@api.expect()` will ensure that all possible args are included in the documentation and nothing is documented that isn't actually available. Using request parsers for documentation also allows code to be more DRY as the parsers can be reused more easily.

**NOTE**: This rule will not run if the route is not a literal constant, as the linter can't tell what route parameters are.

#### DO NOT

```python
request_parser = reqparse.RequestParser()
request_parser.add_argument("resource_id", required=True)


@api.route("/some-route")
class SomeResource(Resource):
    @api.doc(
        id="""Get SomeResource""",
        params={"resource_id": "The resource ID"},
    )
    @api.marshal_with(response)
    def get(self):
        args = route_parser.parse_args()
        resource_id = args.get(resource_id)
        # ...

```

#### DO

```python
request_parser = reqparse.RequestParser(argument_class=DescriptiveArgument)
request_parser.add_argument("resource_id", required=True, description="The resource id")


@api.route("/some-route")
class SomeResource(Resource):
    @api.doc(
        id="""Get SomeResource""",
    )
    @api.expect(request_parser)
    @api.marshal_with(response)
    def get(self):
        args = route_parser.parse_args()
        resource_id = args.get(resource_id)
        # ...
```

### FDP002: Decorators out of order. Decorator "{decorator}" should be above "{another_decorator}" in function decorator list.

Decorator order can be defined using the `--fdp-decorator-order` option in commandline or config. It helps keep the style consistent. Excluded decorators are ignored from order requirements.

**NOTE**: Decorators from eg. `api` are named after the actual method, eg. `@api.expect()` is `expect`.

### FDP003: Keyword args out of order. Arg "{keyword}" should be above "{another_keyword}" in @api.doc() keyword arg list.

Keyword order for the `@api.doc()` decorator can be defined using the `--fdp-api-doc-keyword-order` option in commandline or config. It helps keep the style consistent. Excluded keywords are ignored from order requirements.

### FDP004: Route parameter "{0}" missing from @api.doc() params. Are you missing an @api.expect()?

This rule tries to make sure that any route parameters it finds are documented. This is important if you want a fully documented API.

**NOTE**: If there's a top-level `@api.expect()`, this rule false negatives since the linter can't tell if the request parser documents the parameters.

### FDP005: Missing ID for resource method "{method}". Define an ID using @api.doc(id="<some pretty id>").

This rule tries to ensure every resource method has a custom operation ID. This is important if you want "pretty" operation IDs for documentation rather than the autogenerated paths.
